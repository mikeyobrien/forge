//! ABOUTME: HTML template system for generating static site pages
//! ABOUTME: Provides string-based templates for documents and navigation

use crate::theme::search::generate_search_script;
use crate::Result;
use std::collections::HashMap;

/// Base HTML template for all pages
const BASE_TEMPLATE: &str = r#"<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{title} - PARA SSG</title>
    <style>
        {styles}
    </style>
</head>
<body>
    <header>
        <nav>
            <div class="nav-container">
                <h1><a href="/">PARA Knowledge Base</a></h1>
                <button class="nav-toggle" onclick="toggleNav()" aria-label="Toggle navigation">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
                <ul class="nav-menu" id="navMenu">
                    <li><a href="/projects/" class="{projects_active}">Projects</a></li>
                    <li><a href="/areas/" class="{areas_active}">Areas</a></li>
                    <li><a href="/resources/" class="{resources_active}">Resources</a></li>
                    <li><a href="/archives/" class="{archives_active}">Archives</a></li>
                    <li class="nav-search">
                        <input type="text" class="search-box nav-search-box" placeholder="Search (Ctrl+K)" readonly onclick="openSearch()" />
                    </li>
                </ul>
            </div>
        </nav>
    </header>
    
    <main>
        <div class="container">
            {breadcrumbs}
            {content}
        </div>
    </main>
    
    <footer>
        <div class="container">
            <p>Generated by PARA SSG</p>
        </div>
    </footer>
    
    <script>
        function toggleNav() {
            var navMenu = document.getElementById('navMenu');
            navMenu.classList.toggle('active');
        }
        
        // Close menu when clicking outside
        document.addEventListener('click', function(event) {
            var navMenu = document.getElementById('navMenu');
            var navToggle = document.querySelector('.nav-toggle');
            if (!navMenu.contains(event.target) && !navToggle.contains(event.target)) {
                navMenu.classList.remove('active');
            }
        });
        
        {search_script}
    </script>
</body>
</html>"#;

/// Document page template
const DOCUMENT_TEMPLATE: &str = r#"
<article class="document">
    <header class="document-header">
        <h1>{title}</h1>
        {document_meta}
    </header>
    
    <div class="document-content">
        {content}
    </div>
    
    {backlinks_section}
</article>
"#;

/// Category index page template
const CATEGORY_INDEX_TEMPLATE: &str = r#"
<div class="category-index">
    <h1>{category_title}</h1>
    <p class="category-description">{category_description}</p>
    <p class="document-count">{document_count} documents in this category</p>
    
    <div class="document-list">
        {document_entries}
    </div>
</div>
"#;

/// Document list entry template
const DOCUMENT_ENTRY_TEMPLATE: &str = r#"
<div class="document-entry">
    <h2><a href="{url}">{title}</a></h2>
    {entry_meta}
    {summary}
</div>
"#;

/// Breadcrumb template
const BREADCRUMB_TEMPLATE: &str = r#"
<nav class="breadcrumbs">
    <ol>
        {breadcrumb_items}
    </ol>
</nav>
"#;

/// Template engine that replaces placeholders with values
pub struct TemplateEngine {
    /// Custom templates that override defaults
    custom_templates: HashMap<String, String>,
}

impl TemplateEngine {
    /// Create a new template engine with default templates
    pub fn new() -> Self {
        Self {
            custom_templates: HashMap::new(),
        }
    }

    /// Render the base template with given parameters
    pub fn render_base(
        &self,
        title: &str,
        content: &str,
        active_category: Option<&str>,
        breadcrumbs: Option<&str>,
        styles: &str,
    ) -> Result<String> {
        let mut html = self
            .get_template("base")
            .replace("{title}", &html_escape(title))
            .replace("{content}", content)
            .replace("{styles}", styles)
            .replace("{search_script}", &generate_search_script());

        // Set active navigation state
        let categories = ["projects", "areas", "resources", "archives"];
        for category in &categories {
            let placeholder = format!("{{{}_active}}", category);
            let class = if Some(*category) == active_category {
                "active"
            } else {
                ""
            };
            html = html.replace(&placeholder, class);
        }

        // Add breadcrumbs if provided
        let breadcrumb_html = breadcrumbs.unwrap_or("");
        html = html.replace("{breadcrumbs}", breadcrumb_html);

        Ok(html)
    }

    /// Render a document page
    pub fn render_document(
        &self,
        title: &str,
        content: &str,
        metadata: &DocumentMetadata,
        backlinks: Option<&str>,
    ) -> Result<String> {
        let mut doc_html = self
            .get_template("document")
            .replace("{title}", &html_escape(title))
            .replace("{content}", content);

        // Add document metadata
        let meta_html = self.render_document_meta(metadata);
        doc_html = doc_html.replace("{document_meta}", &meta_html);

        // Add backlinks section if present
        let backlinks_html = if let Some(backlinks) = backlinks {
            format!(
                r#"<section class="backlinks">
                <h2>Backlinks</h2>
                {}
            </section>"#,
                backlinks
            )
        } else {
            String::new()
        };
        doc_html = doc_html.replace("{backlinks_section}", &backlinks_html);

        Ok(doc_html)
    }

    /// Render a category index page
    pub fn render_category_index(
        &self,
        category: &str,
        documents: &[DocumentSummary],
    ) -> Result<String> {
        let category_title = match category {
            "projects" => "Projects",
            "areas" => "Areas",
            "resources" => "Resources",
            "archives" => "Archives",
            _ => category,
        };

        let category_description = match category {
            "projects" => "Active projects with specific outcomes and deadlines",
            "areas" => "Ongoing responsibilities and areas of focus",
            "resources" => "Reference materials and information for future use",
            "archives" => "Inactive items from the other categories",
            _ => "",
        };

        let mut entries = String::new();
        for doc in documents {
            entries.push_str(&self.render_document_entry(doc)?);
            entries.push('\n');
        }

        let document_count = documents.len();
        let html = self
            .get_template("category_index")
            .replace("{category_title}", category_title)
            .replace("{category_description}", category_description)
            .replace("{document_count}", &document_count.to_string())
            .replace("{document_entries}", &entries);

        Ok(html)
    }

    /// Render a single document entry for lists
    pub fn render_document_entry(&self, doc: &DocumentSummary) -> Result<String> {
        let mut entry = self
            .get_template("document_entry")
            .replace("{url}", &doc.url)
            .replace("{title}", &html_escape(&doc.title));

        // Add metadata if present
        let mut meta_parts = Vec::new();
        if let Some(date) = &doc.date {
            meta_parts.push(format!("<time>{}</time>", date));
        }
        if !doc.tags.is_empty() {
            let tags_html = doc
                .tags
                .iter()
                .map(|tag| format!(r#"<span class="tag">{}</span>"#, html_escape(tag)))
                .collect::<Vec<_>>()
                .join(" ");
            meta_parts.push(format!(r#"<div class="tags">{}</div>"#, tags_html));
        }

        let meta_html = if !meta_parts.is_empty() {
            format!(r#"<div class="entry-meta">{}</div>"#, meta_parts.join(" "))
        } else {
            String::new()
        };
        entry = entry.replace("{entry_meta}", &meta_html);

        // Add summary if present
        let summary_html = if let Some(summary) = &doc.summary {
            format!(r#"<p class="summary">{}</p>"#, html_escape(summary))
        } else {
            String::new()
        };
        entry = entry.replace("{summary}", &summary_html);

        Ok(entry)
    }

    /// Render breadcrumb navigation
    pub fn render_breadcrumbs(&self, items: &[BreadcrumbItem]) -> Result<String> {
        if items.is_empty() {
            return Ok(String::new());
        }

        let mut crumb_html = String::new();
        for (i, item) in items.iter().enumerate() {
            if i > 0 {
                crumb_html.push_str(r#"<li class="separator">/</li>"#);
            }

            if let Some(url) = &item.url {
                crumb_html.push_str(&format!(
                    r#"<li><a href="{}">{}</a></li>"#,
                    url,
                    html_escape(&item.title)
                ));
            } else {
                crumb_html.push_str(&format!(
                    r#"<li class="current">{}</li>"#,
                    html_escape(&item.title)
                ));
            }
        }

        let html = self
            .get_template("breadcrumb")
            .replace("{breadcrumb_items}", &crumb_html);

        Ok(html)
    }

    /// Get a template by name, using custom if available
    fn get_template(&self, name: &str) -> &str {
        if let Some(custom) = self.custom_templates.get(name) {
            return custom;
        }

        match name {
            "base" => BASE_TEMPLATE,
            "document" => DOCUMENT_TEMPLATE,
            "category_index" => CATEGORY_INDEX_TEMPLATE,
            "document_entry" => DOCUMENT_ENTRY_TEMPLATE,
            "breadcrumb" => BREADCRUMB_TEMPLATE,
            _ => BASE_TEMPLATE,
        }
    }

    /// Render document metadata section
    fn render_document_meta(&self, metadata: &DocumentMetadata) -> String {
        let mut meta_parts = Vec::new();

        if let Some(author) = &metadata.author {
            meta_parts.push(format!(
                r#"<span class="author">By {}</span>"#,
                html_escape(author)
            ));
        }

        if let Some(date) = &metadata.date {
            meta_parts.push(format!(r#"<time class="date">{}</time>"#, date));
        }

        if let Some(status) = &metadata.status {
            meta_parts.push(format!(
                r#"<span class="status status-{}">{}</span>"#,
                status.to_lowercase(),
                html_escape(status)
            ));
        }

        if !metadata.tags.is_empty() {
            let tags_html = metadata
                .tags
                .iter()
                .map(|tag| format!(r#"<span class="tag">{}</span>"#, html_escape(tag)))
                .collect::<Vec<_>>()
                .join(" ");
            meta_parts.push(format!(r#"<div class="tags">{}</div>"#, tags_html));
        }

        if meta_parts.is_empty() {
            String::new()
        } else {
            format!(
                r#"<div class="document-meta">{}</div>"#,
                meta_parts.join("\n")
            )
        }
    }
}

impl Default for TemplateEngine {
    fn default() -> Self {
        Self::new()
    }
}

/// Document metadata for template rendering
pub struct DocumentMetadata {
    pub author: Option<String>,
    pub date: Option<String>,
    pub status: Option<String>,
    pub tags: Vec<String>,
}

/// Summary information for document listings
pub struct DocumentSummary {
    pub url: String,
    pub title: String,
    pub date: Option<String>,
    pub tags: Vec<String>,
    pub summary: Option<String>,
}

/// Breadcrumb navigation item
pub struct BreadcrumbItem {
    pub title: String,
    pub url: Option<String>,
}

/// HTML escape special characters
fn html_escape(text: &str) -> String {
    text.replace('&', "&amp;")
        .replace('<', "&lt;")
        .replace('>', "&gt;")
        .replace('"', "&quot;")
        .replace('\'', "&#39;")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_html_escape() {
        assert_eq!(html_escape("Test & <escape>"), "Test &amp; &lt;escape&gt;");
        assert_eq!(
            html_escape(r#"Quote "test" 'single'"#),
            "Quote &quot;test&quot; &#39;single&#39;"
        );
    }

    #[test]
    fn test_render_base_template() {
        let engine = TemplateEngine::new();
        let html = engine
            .render_base(
                "Test Page",
                "<p>Content</p>",
                Some("projects"),
                None,
                "body { margin: 0; }",
            )
            .unwrap();

        assert!(html.contains("<title>Test Page - PARA SSG</title>"));
        assert!(html.contains("<p>Content</p>"));
        assert!(html.contains(r#"class="active">Projects</a>"#));
        assert!(html.contains("body { margin: 0; }"));
    }

    #[test]
    fn test_render_document() {
        let engine = TemplateEngine::new();
        let metadata = DocumentMetadata {
            author: Some("Test Author".to_string()),
            date: Some("2023-01-15".to_string()),
            status: Some("published".to_string()),
            tags: vec!["rust".to_string(), "testing".to_string()],
        };

        let html = engine
            .render_document("Test Document", "<p>Document content</p>", &metadata, None)
            .unwrap();

        assert!(html.contains("<h1>Test Document</h1>"));
        assert!(html.contains("<p>Document content</p>"));
        assert!(html.contains("By Test Author"));
        assert!(html.contains("2023-01-15"));
        assert!(html.contains("status-published"));
        assert!(html.contains(r#"<span class="tag">rust</span>"#));
    }

    #[test]
    fn test_render_category_index() {
        let engine = TemplateEngine::new();
        let documents = vec![DocumentSummary {
            url: "/projects/test.html".to_string(),
            title: "Test Project".to_string(),
            date: Some("2023-01-15".to_string()),
            tags: vec!["important".to_string()],
            summary: Some("A test project".to_string()),
        }];

        let html = engine
            .render_category_index("projects", &documents)
            .unwrap();

        assert!(html.contains("<h1>Projects</h1>"));
        assert!(html.contains("Active projects with specific outcomes"));
        assert!(html.contains(r#"href="/projects/test.html""#));
        assert!(html.contains("Test Project"));
        assert!(html.contains("A test project"));
    }

    #[test]
    fn test_render_breadcrumbs() {
        let engine = TemplateEngine::new();
        let items = vec![
            BreadcrumbItem {
                title: "Home".to_string(),
                url: Some("/".to_string()),
            },
            BreadcrumbItem {
                title: "Projects".to_string(),
                url: Some("/projects/".to_string()),
            },
            BreadcrumbItem {
                title: "Current Page".to_string(),
                url: None,
            },
        ];

        let html = engine.render_breadcrumbs(&items).unwrap();

        assert!(html.contains(r#"<a href="/">Home</a>"#));
        assert!(html.contains(r#"<a href="/projects/">Projects</a>"#));
        assert!(html.contains(r#"<li class="current">Current Page</li>"#));
        assert!(html.contains(r#"<li class="separator">/</li>"#));
    }

    #[test]
    fn test_empty_breadcrumbs() {
        let engine = TemplateEngine::new();
        let html = engine.render_breadcrumbs(&[]).unwrap();
        assert_eq!(html, "");
    }
}
